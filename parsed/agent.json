[[{"content":[{"content":[],"type":"paragraph"},{"content":[{"content":"When people build ","type":"plain"},{"content":{"content":[{"content":"agentic systems","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":", two mysterious tendencies often appear:","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"type":"itemization","items":[{"content":[],"type":"normal-item","title":{"content":[{"content":"They design systems for ","type":"plain"},{"content":{"content":[{"content":"GUI use only","type":"plain"}],"type":"paragraph"},"type":"bold"},{"content":".","type":"plain"}],"type":"paragraph"}},{"content":[],"type":"normal-item","title":{"content":[{"content":"They aim for ","type":"plain"},{"content":{"content":[{"content":"purely automatic systems","type":"plain"}],"type":"paragraph"},"type":"bold"},{"content":".","type":"plain"}],"type":"paragraph"}}]},{"content":[],"type":"paragraph"},{"content":[{"content":"Some developers do attempt an ","type":"plain"},{"content":{"content":[{"content":"agent CLI","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":", yet even then, it’s often highly automatic—less managed, less flexible.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"This partition of use cases tends to be ignored. However, there remains a real need for ","type":"plain"},{"content":{"content":[{"content":"flexible, fully controlled agents","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":"—tools that let users, for example, manually specify a list of files to read, or interact step-by-step with the agent’s logic.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"}],"type":"section","date":null,"title":{"content":[{"content":" Towards Flexible Agent CLI","type":"plain"}],"type":"paragraph"}},{"content":[{"content":[],"type":"paragraph"},{"content":[{"content":"Today we have a variety of tools that generate prompts for LLMs. The most common pattern is to extract data from a ","type":"plain"},{"content":{"content":[{"content":"so-called","type":"plain"}],"type":"paragraph"},"type":"underlined"},{"content":" ","type":"plain"},{"content":{"content":[{"content":"knowledge base","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":". But our approaches to ","type":"plain"},{"content":{"content":[{"content":"composing prompts","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":" are generally inefficient. The only flexible method most people use is to ","type":"plain"},{"content":{"content":[{"content":"copy, paste, and concatenate.","type":"plain"}],"type":"paragraph"},"type":"italic"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"Consider this: you want to insert the output of a command or your clipboard contents into a prompt. Typical agent CLIs provide options like `chat --clipboard` or `chat --edit`, which simply pass your clipboard content into the model (sometimes after a quick edit). And that’s it.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"While such options “do one thing,” the UNIX philosophy reminds us not only to “do one thing” but to ","type":"plain"},{"content":{"content":[{"content":"DO IT BEST","type":"plain"}],"type":"paragraph"},"type":"bold"},{"content":". Current integrations lack ","type":"plain"},{"content":{"content":[{"content":"composability","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":"—arguments (`args`) are the only handles we get. That’s too rigid for a system that should thrive on modularity.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"}],"type":"section","date":null,"title":{"content":[{"content":" For Shell Integration / Composition","type":"plain"}],"type":"paragraph"}},{"content":[{"content":[],"type":"paragraph"},{"content":"What is beyond args?\nTraditional tools also rely only on args,\nand they provide extremely well composibility.\n","type":"code-block","language":"Some may have doubts","line-number":null},{"content":[],"type":"paragraph"},{"content":[{"content":"That’s true for traditional systems—but agents are not traditional tools.","type":"plain"}],"type":"paragraph"},{"content":[{"content":"Agents don’t just process simple data—they interpret ","type":"plain"},{"content":{"content":[{"content":"context","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":", they integrate with your ","type":"plain"},{"content":{"content":[{"content":"system capabilities","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":", and increasingly, ","type":"plain"},{"content":{"content":[{"content":"multi-modal inputs","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":".","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"At their core, agents are ","type":"plain"},{"content":{"content":[{"content":"tools that hold context","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":" and ","type":"plain"},{"content":{"content":[{"content":"respond dynamically","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":" to your input. In that sense, they’re remarkably similar to REPLs (Read–Eval–Print Loops). I call this the `REPL nature of agents`.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"Every major requirement of an agent echoes the REPL concept:","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"type":"itemization","items":[{"content":[],"type":"normal-item","title":{"content":[{"content":"multi-round conversation mirrors shell session state;","type":"plain"}],"type":"paragraph"}},{"content":[],"type":"normal-item","title":{"content":[{"content":"managed resources and input data correspond to REPL variables.","type":"plain"}],"type":"paragraph"}}]},{"content":[],"type":"paragraph"},{"content":[{"content":"Once you recognize this, it becomes easy to write small tools and plugins to compose prompts more flexibly.","type":"plain"}],"type":"paragraph"},{"content":[{"content":"The rigid `--clipboard` option evolves into a ","type":"plain"},{"content":{"content":[{"content":"pipeline","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":" — something like:","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":"xclip | parse | transform | user_defined_function\n","type":"code-block","language":"","line-number":null},{"content":[],"type":"paragraph"},{"content":[{"content":"Each step becomes a piece of your composable agent workflow.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"}],"type":"section","date":null,"title":{"content":[{"content":" REPL-ish Agents","type":"plain"}],"type":"paragraph"}},{"content":[{"content":[],"type":"paragraph"},{"content":[{"content":"Now, how do we implement such a REPL elegantly?","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"This concept should live inside each language’s most natural REPL environment. Let’s take JavaScript as an example.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"Launching a REPL in Node.js is straightforward. Adding `zx` helps integrate shell-like plugins smoothly.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":[{"content":"The core idea: expose a ","type":"plain"},{"content":{"content":[{"content":"magic function","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":" in the REPL that accepts ","type":"plain"},{"content":{"content":[{"content":"literate, composable input","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":"—something that feels like writing Markdown, but with double backticks for clarity.","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"},{"content":"await ask`use the tagged template string syntax\nto accept literate strings,\n${interpolations} ``and fenced area``\nthe writing feeling is just like markdown with\nevery sequence of backtick extended once more,\ni.e. one -> two, three -> four.\n\n````handler\nyes, a little bit of magic used here allows\ncodeblock-ish syntax. and replace handler\nwith a real plugin's name, like ``shell``,\nwill embed the output of the plugin into\nthe prompt to compose the prompt.\nThis is my answer to composibility.\n````\nsimilarly, used an empty template string to\nexit the plugin's environment\n(oh, poor highlight.js\n    does not make this highlight correct\n,,, not even close\n)\n`() // use empty arguments' call at last \n// to invoke LLM\n","type":"code-block","language":"javascript","line-number":null},{"content":[],"type":"paragraph"}],"type":"section","date":null,"title":{"content":[{"content":" Implementation","type":"plain"}],"type":"paragraph"}},{"content":[{"content":[{"content":"this pattern merges literate programming, shell composability, and REPL interaction into one coherent CLI paradigm—a genuinely ","type":"plain"},{"content":{"content":[{"content":"flexible agent interface","type":"plain"}],"type":"paragraph"},"type":"italic"},{"content":".","type":"plain"}],"type":"paragraph"},{"content":[],"type":"paragraph"}],"type":"section","date":null,"title":{"content":[{"content":" In short","type":"plain"}],"type":"paragraph"}}],[]]
